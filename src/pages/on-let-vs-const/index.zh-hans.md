---
title: let 和 const 对比
date: '2019-12-22'
spoiler: 我应该使用哪一个？
---

我的 [上一篇文章](/what-is-javascript-made-of/) 包含了这一段内容：

> **`let` vs `const` vs `var`**: 通常你可以使用 `let`，如果你想去禁止对这个变量赋值（不是初始化），你可以使用 `const`。当这个变量只有一次赋值（初始化）的时候，一些迂腐的代码库和同事会强迫你去使用 `const`。

事实证明这是非常具有争议性的，引发了在 Twitter 和 Reddit 上的对话。看来多数人的观点（至少，最明确表达的观点）是应该尽可能的使用 `const`，仅仅在必要的时候再回退到 `let`，可以启用 ESLint 的[`prefer-const`](https://eslint.org/docs/rules/prefer-const)  规则来强制规范这个行为。

在这篇文章中，我会简要的总结一些我遇到的论点和相反的论点，以及我个人对这篇文章的总结。

## 为什么用 `prefer-const`
* **一种实现方法**: 每次都必须在 `let` 和 `const` 之间做选择是很麻烦的事情，一些像 "始终在能使用 `const` 的地方使用 `const`"的规则可以让你必须思考这些问题，这些规则可以由 linter 强制执行。
* **重新赋值可能导致 bug**: 在比较长的函数中，当变量被重新赋值时，很容易被忽略。这可能会导致一些 bug。特别是在闭包中，`const` 会给足你信心让你总是看到相同的值。
* **了解变更**: 刚接触 JavaScript 的人应该会感到困惑，认为 `const` 意味着不可变。但是，有人可能会认为无论如何了解变量变更（Mutation）和赋值的区别是很重要的，而喜欢用 `const` 会强制你更早的去面对这些区别。
* **无意义的赋值**: 有时，赋值完全没有意义。例如使用 React Hooks 时，从像 `useState` 的 hook 获取的值更像是参数，这个数据的流向是单向的，看到赋值的错误能帮你今早的了解 React 的数据流。
* **性能优势**: 偶尔有人认为，因为 JS 引擎知道变量不会再次赋值，使用 `const` 的代码会运行的更快。

## 为什么不用 `prefer-const`

* **失去意图**: 如果我们在任何地方都强制使用 `const`，我们就失去了了沟通不重新重新赋值某些东西是否重要的能力。
* **不可变性的困惑**: 在任何关于为什么你应该首选 `const` 的讨论中，总有人对不可变性感到困惑。这不足为奇，因为赋值和变更都使用相同的 `=` 操作符。作为回应，人们通常被告知他们应该 “只是学习语言”。然而，一个相反的观点是如果一个防止初学者犯错的功能使初学者感到困惑，那他们并不是特别有帮助。不幸的是，它并没有帮助防止跨模块和影响所有人的变更错误。
* **避免重新定义的压力**: `const` 优先的代码库会制造一种压力让你不要去使用 `let` 条件的赋值给变量。比如，你可能会用 `const a = cond ? b : c` 来替代 `if` 条件，即使 `b` 和 `c` 的条件分支都很复杂，以及给它们指定明确的名字也很尴尬。
* **重新赋值可能并不会导致 bug**: 重新赋值导致 bug 的三种常见的情况：当作用域非常大的时候（像模块作用域或者巨大的函数），当这个值是参数的时候（传递这个参数意料之外的值），和当这个变量在一个嵌套函数中使用的时候。但是在许多代码库中，大多数变量不满足任何一种情况，以及参数根本无法被标记为常量。
* **没有性能上的优势**: 据我所知，JS 引擎已经知道哪些变量仅仅被赋值一次 -- 尽管你使用 `var` 或者 `let`，如果我们继续追问，我们会知道额外的检查会带来性能开销，而不是减少。但是说真的，JS 引擎很聪明。

## 我的结论
我并不关心。

我使用代码库已经有的任何规范。

如果你在意，使用可以自动检查和修复的 linter 以便将 `let` 修改为 `const` 不会延迟代码审查。

最后，记住 linter 的存在就是为了服务你。如果 linter 的规则困扰你和你的团队，请删除它。它并不是那么有价值。
从你自己的错误中学习。
---
title: Escribir components resilientes
date: '2019-03-16'
spoiler: Cuatro principios para guiarte por el camino correcto.
---

Cuando alguien comienza a estudiar React a menudo pide una gu√≠a de estilo. Si bien es una buena idea aplicar consistentemente algunas reglas en un proyecto, muchas de ellas son arbitrarias ‚Äîy por tanto React no tiene una opini√≥n tajante sobre ellas‚Äî.

Puedes usar diferentes sistemas de tipos, preferir declaraciones o funciones flecha, ordenar tus props en orden alfab√©tico o en cualquier orden que te resulte agradable.

Esta flexibilidad permite que se [React se integre](https://reactjs.org/docs/add-react-to-a-website.html) en proyectos con convenciones ya existentes. Pero tambi√©n da lugar a debates interminables.

**_S√≠ hay_ principios de dise√±o importantes que todo componente deber√≠a intentar seguir. Pero no creo que las gu√≠as de estilo capturen bien esos principios. Hablaremos primero sobre las gu√≠as de estilo, y luego [le echaremos un vistazo a los principio que _son_ realmente √∫tiles](#writing-resilient-components).**

---

## No te dejes distraer por problemas imaginarios

Antes de que abordemos los principios de dise√±o de componentes, quisiera dedicar algunas palabras a las gu√≠as de estilo. ¬°Esta no es una opini√≥n popular, pero alguien tiene que decirla!

En la comunidad de JavaScript hay algunas gu√≠as de estilo estrictas y dogm√°ticas que se hacen cumplir por un _linter_. Mi observaci√≥n personal es que suelen crear m√°s fricci√≥n que el valor que tienen. Son innumerables las veces que alguien me ha mostrado un c√≥digo completamente v√°lido y me ha dicho ¬´React se queja por esto¬ª, ¬°pero era el _linter_ quien se quejaba! Esto conduce a tres problemas:

* Las personas se acostumbran a ver al _linter_ m√°s como un **guardi√°n excesivamente ruidoso** que como una herramienta √∫til. Las advertencias √∫tiles quedan ahogadas en el mar de minucias de estilo. Al final, no revisan los mensajes del _linter_ mientras depuran el c√≥digo, y se pierden consejos √∫tiles. A√∫n m√°s, quienes est√°n menos acostumbradas a escribir JavaScript (por ejemplo, los dise√±adores) se les hace m√°s dif√≠cil trabajar con el c√≥digo.

* Las personas no aprenden a **diferenciar entre usos v√°lidos e inv√°lidos** de un patr√≥n determinado. Por ejemplo, hay una regla popular que proh√≠be llamar a `setState` dentro de `componentDidMount`. ¬°Pero, si siempre fuera ¬´malo¬ª, React simplemente no lo permitir√≠a! Hay una caso de uso leg√≠timo: para hacer mediciones de la maquetaci√≥n del nodo del DOM (por ejemplo, para posicionar un globo de ayuda). He visto personas ¬´sortear¬ª esta regla a√±adiendo `setTimeout`, lo que no tiene ning√∫n sentido.

* Tarde o temprano, las personas adoptan el papel de ¬´agente que hace cumplir las normas¬ª y se vuelven dogm√°ticas sobre cosas que **no aportan ninguna diferencia significativa**, pero que son f√°ciles de encontrar en el c√≥digo. ¬´Usaste una declaraci√≥n de funci√≥n, pero *nuestro* proyecto usa funciones flecha¬ª. Cada vez que tengo una opini√≥n tajante sobre hacer cumplir una regla como esta, si me detengo a analizar con profundidad resulta que he invertido esfuerzo emocional en esta regla ‚Äîy me cuesta dejarla ir‚Äî. Me adormece en la falsa sensaci√≥n de haber logrado algo sin mejorar mi c√≥digo.

¬øAcaso estoy diciendo que deber√≠amos dejar de usar un _linter_? ¬°Para nada!

**Con una buena configuraci√≥n, un _linter_ es una herramienta magn√≠fica para detectar errores antes de que ocurran.** Es el enfoque excesivo en el *estilo* lo que lo convierte en una distracci√≥n.

---

## Haz un Marie Kondo a tu configuraci√≥n del _linter_

Esto es lo que te sugiero que hagas el lunes. Re√∫ne a tu equipo por media hora, recorre cada regla del _linter_ que est√© habilitada en la configuraci√≥n de tu proyecto y preg√∫ntate: *¬´¬øEsta regla nos ha ayudado alguna vez a detectar un error?¬ª*. Si no es el caso, *desact√≠vala.* (Tambi√©n puedes empezar de cero con [`eslint-config-react-app`](https://www.npmjs.com/package/eslint-config-react-app) que no tiene reglas de estilo).

Como m√≠nimo, tu equipo deber√≠a tener un proceso para eliminar reglas que causan fricci√≥n. No asumas que algo que t√∫ o alguien m√°s a√±adi√≥ a tu configuraci√≥n del _linter_ hace un a√±o es una ¬´buena pr√°ctica¬ª. Cuesti√≥nalo y busca respuestas. No dejes que nadie te diga que no eres lo suficientemente inteligente para elegir tus reglas del _linter_.

**¬øPero, y el formateo?** Usa [Prettier](https://prettier.io/) y olv√≠date de las ¬´minucias de estilo¬ª. No necesitas una herramienta que te grite por un espacio adicional si otra herramienta puede arreglarlo por ti. Usa el _linter_ para encontrar *errores*, no para hacer cumplir las reglas de *e s t √© t i c a*.

Por supuesto, hay elementos del estilo de c√≥digo que no est√°n relacionados directamente con el formateo, pero pueden ser molestos cuando son inconsistentes en un proyecto.

Sin embargo, muchos de ellos son muy sutiles para detectarlos con una regla del _linter_. Por eso es importante **construir confianza** entre los miembros del equipo y compartir conocimientos √∫tiles en la forma de una p√°gina wiki o una peque√±a gu√≠a de dise√±o.

¬°No todo vale la pena automatizarlo! La comprensi√≥n ganada de *realmente leer* las razones en esa gu√≠a puede ser m√°s valioso que seguir las ¬´reglas¬ª.

**Pero si seguir una gu√≠a de estilo estricta es una distracci√≥n, ¬øqu√© es realmente importante?**

Ese es el tema de este art√≠culo.

---

## Escribir componentes resilientes

No existe una cantidad de tabulaci√≥n o de organizar _imports_ alfab√©ticamente que arregle un dise√±o roto. Es por eso que en lugar de enfocarme en c√≥mo *luce* el c√≥digo, lo har√© en c√≥mo *funciona*. Hay algunos principios de dise√±os de componentes que encuentro muy √∫tiles:

1. **[No detengas el flujo de datos](#principle-1-dont-stop-the-data-flow)**
2. **[Estate listo siempre para renderizar](#principle-2-always-be-ready-to-render)**
3. **[Ning√∫n componente es un *singleton*](#principle-3-no-component-is-a-singleton)**
4. **[Mant√©n aislado el estado local](#principle-4-keep-the-local-state-isolated)**

Incluso si no usas React, descubrir√°s los mismos principios por prueba y error en cualquier modelo de componentes de UI con un flujo de datos unidireccional.

---

## Principio 1: No detengas el flujo de datos

### No detengas el flujo de datos en el renderizado

Cuando alguien utiliza tu componente, espera que pueda pasar diferentes props a trav√©s del tiempo y que el componente refleje esos cambios:

```jsx
// isOk podr√≠a estar determinado por el estado y cambiar a trav√©s del tiempo
<Button color={isOk ? 'blue' : 'red'} />
```

De forma general, es as√≠ como React funciona por defecto. Si usas una prop `color` dentro de un componente `Button`, ver√°s para ese renderizado el valor que se proporcion√≥ desde arriba:

```jsx
function Button({ color, children }) {
  return (
    // ‚úÖ ¬°`color` siempre est√° fresco!
    <button className={'Button-' + color}>
      {children}
    </button>
  );
}
```

Sin embargo, un error com√∫n cuando se est√° aprendiendo React consiste en copiar las props en el estado:

```jsx{3,6}
class Button extends React.Component {
  state = {
    color: this.props.color
  };
  render() {
    const { color } = this.state; // üî¥ ¬°`color` no est√° fresco!
    return (
      <button className={'Button-' + color}>
        {this.props.children}
      </button>
    );
  }
}
```

Esto puede que te parezca intuitivo en un inicio si has usado clases fuera de React. **Sin embargo, al copiar una prop en el estado est√°s ignorando todas las actualizaciones que se le hagan.**

```jsx
// üî¥ Ya no funciona para las actualizaciones con la implementaci√≥n de arriba
<Button color={isOk ? 'blue' : 'red'} />
```

En el caso excepcional en que este comportamiento *es* intencional, aseg√∫rate de nombrar esa prop `initialColor` o `defaultColor` para aclarar de que los cambios que tenga ser√°n ignorados.

Pero lo com√∫n ser√° **leer las props directamente en tu componente** y evitar copiar las props (o cualquier cosa que se calcule a partir de las props) en el estado:

```jsx
function Button({ color, children }) {
  return (
    // ‚úÖ ¬°`color` siempre est√° fresco!
    <button className={'Button-' + color}>
      {children}
    </button>
  );
}
```

----

Los valores calculados son otra raz√≥n por la que a veces se intenta copiar las props en el estado. Por ejemplo, imagina que se determine el color del *texto del bot√≥n* con base en un c√°lculo costoso que toma el `color` del fondo como argumento:

```jsx{3,9}
class Button extends React.Component {
  state = {
    textColor: slowlyCalculateTextColor(this.props.color)
  };
  render() {
    return (
      <button className={
        'Button-' + this.props.color +
        ' Button-text-' + this.state.textColor // üî¥ No se refresca cuando la prop `color` se actualiza
      }>
        {this.props.children}
      </button>
    );
  }
}
```

Este componente es propenso a errores porque no recalcula `this.state.textColor` cuando la prop `color` cambia. La forma m√°s sencilla de solucionarlo implica mover el c√°lculo de `textColor` al m√©todo `render`, y convertir el  componente en `PureComponent`:

```jsx{1,3}
class Button extends React.PureComponent {
  render() {
    const textColor = slowlyCalculateTextColor(this.props.color);
    return (
      <button className={
        'Button-' + this.props.color +
        ' Button-text-' + textColor // ‚úÖ Siempre fresco
      }>
        {this.props.children}
      </button>
    );
  }
}
```

¬°Problema resuelto! Ahora si las props cambian recalcularemos `textColor`, pero evitamos el c√°lculo costoso si las props son las mismas.

Sin embargo, podr√≠amos optimizarlo a√∫n m√°s. ¬øY si lo que cambia es la prop `children`? Resulta desafortunado recalcular `textColor` en ese caso. Nuestro segundo intento podr√≠a ser invocar el c√°lculo en `componentDidUpdate`:

```jsx{5-12}
class Button extends React.Component {
  state = {
    textColor: slowlyCalculateTextColor(this.props.color)
  };
  componentDidUpdate(prevProps) {
    if (prevProps.color !== this.props.color) {
      // üòî Rerenderizado extra para cada actualizaci√≥n
      this.setState({
        textColor: slowlyCalculateTextColor(this.props.color),
      });
    }
  }
  render() {
    return (
      <button className={
        'Button-' + this.props.color +
        ' Button-text-' + this.state.textColor // ‚úÖ Fresco en el renderizado final
      }>
        {this.props.children}
      </button>
    );
  }
}
```

Sin embargo, esto se traduce en que nuestro componente hace un segundo rerenderizado luego de cada cambio. Eso tampoco es ideal si lo que estamos es intentarlo optimizar.

Podr√≠as usar el antiguo m√©todo de ciclo de vida `componentWillReceiveProps`. Sin embargo, ah√≠ las personas suelen poner tambi√©n efectos secundarios. Eso, luego, causar√≠a problemas para funcionalidades futuras del renderizado concurrente [como la segmentaci√≥n de tiempo y _Suspense_](https://es.reactjs.org/blog/2018/03/01/sneak-peek-beyond-react-16.html). Y el m√©todo ¬´m√°s seguro¬ª `getDerivedStateFromProps` es complejo e inc√≥modo.

Deteng√°monos y demos un paso atr√°s. En efecto, deseamos [*memoizaci√≥n*](https://es.wikipedia.org/wiki/Memoizaci%C3%B3n). Tenemos algunas entradas, y no queremos recalcular la salida a menos que las entradas cambien.

Con una clase, podr√≠as usar un [utilitario](https://es.reactjs.org/blog/2018/06/07/you-probably-dont-need-derived-state.html#what-about-memoization) para la memoizaci√≥n. Sin embargo, los Hooks van un paso m√°s all√° e incorporan una forma de memoizar c√°lculos costosos:

```jsx{2-5}
function Button({ color, children }) {
  const textColor = useMemo(
    () => slowlyCalculateTextColor(color),
    [color] // ‚úÖ Se recalcula solo si cambia `color`
  );
  return (
    <button className={'Button-' + color + ' Button-text-' + textColor}>
      {children}
    </button>
  );
}
```

¬°Ese es todo el c√≥digo que necesitas!

En un componente de clase, puedes usar un utilitario como [`memoize-one`](https://github.com/alexreardon/memoize-one). En un componente de funci√≥n, el Hook `useMemo` te ofrece una funcionalidad similar.

Ya hemos visto que **incluso optimizar c√°lculos costosos no es una buena raz√≥n para copiar props en el estado.** Nuestro renderizado deber√≠a respertar los cambios a las props.

---

### No detengas el flujo de datos en los efectos secundarios

Hasta ahora hemos hablado de c√≥mo hacer que el resultado del renderizado se mantenga consistente con los cambios de las props. Evitar copiar props en el estado es una parte. Sin embargo, es importante que **los efectos secundarios (como la carga de datos) sean tambi√©n parte del flujo de datos**.

Tomemos como ejemplo este componente de React:

```jsx{5-7}
class SearchResults extends React.Component {
  state = {
    data: null
  };
  componentDidMount() {
    this.fetchResults();
  }
  fetchResults() {
    const url = this.getFetchUrl();
    // Se hace la carga de datos...
  }
  getFetchUrl() {
    return 'http://myapi/results?query' + this.props.query;
  }
  render() {
    // ...
  }
}
```

Muchos componentes de React son as√≠: pero si nos detenemos a mirar un poco, podremos notar un error. El m√©todo `fetchResults` utiliza la prop `query` para hacer la carga de datos:

```jsx{2}
  getFetchUrl() {
    return 'http://myapi/results?query' + this.props.query;
  }
```

¬°Pero qu√© pasa si cambia la prop `query`? En nuestro componente, no pasar√° nada. **Esto significa que los efectos secundarios de nuestro componente no respetan los cambios en sus props.** Esta es una fuente com√∫n de errores en las aplicaciones de React.

Para arreglar nuestro componente, debemos:

* Fijarnos en `componentDidMount` y en cada m√©todo que se llama desde √©l.
  - En nuestro ejemplo, son `fetchResults` y `getFetchUrl`.
* Apuntar todas las props y estado que estos m√©todos usan.
  - En nuestro ejemplo, es `this.props.query`.
* Aseg√∫rate de que cada vez que esas props cambien, volvamos a ejecutar el efecto secundario.
  - Podemos hacerlo si a√±adimos el m√©todo `componentDidUpdate`.

```jsx{8-12,18}
class SearchResults extends React.Component {
  state = {
    data: null
  };
  componentDidMount() {
    this.fetchResults();
  }
  componentDidUpdate(prevProps) {
    if (prevProps.query !== this.props.query) { // ‚úÖ Volver a cargar cuando hay un cambio
      this.fetchResults();
    }
  }
  fetchResults() {
    const url = this.getFetchUrl();
    // Se hace la carga de datos...
  }
  getFetchUrl() {
    return 'http://myapi/results?query' + this.props.query; // ‚úÖ Se manejan las actualizaciones
  }
  render() {
    // ...
  }
}
```

Ahora nuestro c√≥digo respeta todos los cambios a las props, incluso para los efectos secundarios.

Sin embargo, es complicado no volver a cometer el error. Por ejemplo, podr√≠amos a√±adir `currentPage` al estado local y usarlo en `getFetchUrl`:

```jsx{4,21}
class SearchResults extends React.Component {
  state = {
    data: null,
    currentPage: 0,
  };
  componentDidMount() {
    this.fetchResults();
  }
  componentDidUpdate(prevProps) {
    if (prevProps.query !== this.props.query) {
      this.fetchResults();
    }
  }
  fetchResults() {
    const url = this.getFetchUrl();
    // Se hace la carga de datos...
  }
  getFetchUrl() {
    return (
      'http://myapi/results?query' + this.props.query +
      '&page=' + this.state.currentPage // üî¥ Se ignoran las actualizaciones
    );
  }
  render() {
    // ...
  }
}
```

Vaya, nuestro c√≥digo es propenso a errores nuevamente porque nuestro efecto secundario no respeta los cambios a `currentPage`.

**Las props y el estado son parte del flujo de datos de React. Tanto el renderizado como los efectos secundarios deben reflejar los cambios en el flujo de datos, ¬°no ignorarlos!**

Para arreglar nuestro c√≥digo, podemos repetir los pasos de arriba:

* Fijarnos en `componentDidMount` y en cada m√©todo que se llama desde √©l.
  - En nuestro ejemplo, son `fetchResults` y `getFetchUrl`.
* Apuntar todas las props y estado que estos m√©todos usan.
  - En nuestro ejemplo, son `this.props.query` **y `this.state.currentPage`**.
* Aseg√∫rate de que cada vez que esas props cambien, volvamos a ejecutar el efecto secundario.
  - Podemos hacerlo si a√±adimos el m√©todo `componentDidUpdate`.

Arreglemos nuestro componente para manejar las actualizaciones al estado `currentPage`:

```jsx{11,24}
class SearchResults extends React.Component {
  state = {
    data: null,
    currentPage: 0,
  };
  componentDidMount() {
    this.fetchResults();
  }
  componentDidUpdate(prevProps, prevState) {
    if (
      prevState.currentPage !== this.state.currentPage || // ‚úÖ Volver a cargar cuando hay un cambio
      prevProps.query !== this.props.query
    ) {
      this.fetchResults();
    }
  }
  fetchResults() {
    const url = this.getFetchUrl();
    // Se hace la carga de datos...
  }
  getFetchUrl() {
    return (
      'http://myapi/results?query' + this.props.query +
      '&page=' + this.state.currentPage // ‚úÖ Se manejan las actualizaciones
    );
  }
  render() {
    // ...
  }
}
```

**¬øNo estar√≠a bien si de alguna forma pudi√©semos detectar estos errores?** ¬øNo es esto algo con lo que un _linter_ nos pudiera ayudar?

---

Desafortunadamente, comprobar autom√°ticamente la consistencia de un componente de clase es muy dif√≠cil. Cualquier m√©todo puede llamar a otro. El an√°lisis est√°tico de las llamadas que se hacen en `componentDidMount` y `componentDidUpdate` est√° lleno de falsos positivos.

Sin embargo, se *podr√≠a* dise√±ar una API que *pueda* analizarse est√°ticamente para comprobar la consistencia. El [Hook `useEffect` de React](/a-complete-guide-to-useeffect/) es un ejemplo de este tipo de API:

```jsx{13-14,19}
function SearchResults({ query }) {
  const [data, setData] = useState(null);
  const [currentPage, setCurrentPage] = useState(0);

  useEffect(() => {
    function fetchResults() {
      const url = getFetchUrl();
      // Se hace la carga de datos...
    }

    function getFetchUrl() {
      return (
        'http://myapi/results?query' + query +
        '&page=' + currentPage
      );
    }

    fetchResults();
  }, [currentPage, query]); // ‚úÖ Volver a cargar cuando hay un cambio

  // ...
}
```

Ponemos la l√≥gica *dentro* del efecto, lo que facilita ver de *qu√© valores del flujo de datos de React* depende. Estos valores se llaman ¬´dependencias¬ª y en nuestro ejemplo son `[currentPage, query]`.

F√≠jate como este arreglo de ¬´dependencias del efecto¬ª en realidad no es un nuevo concepto. En una clase, ten√≠amos que buscar estas ¬´dependencias¬ª por todas las llamadas de los m√©todos. la API `useEffect` hace que el mismo concepto sea expl√≠cito.

Ahora, esto nos permite hacer la validaci√≥n autom√°ticamente:

![Demo de la regla del _linter_ exhaustive-deps](./useeffect.gif)

*(Esta es una demo de la nueva regla recomendada del _linter_ `exhaustive-deps` que es parte de `eslint-plugin-react-hooks`. Pronto se incluir√° en Create React App).*

**F√≠jate que es importante respetar todas las actualizaciones de las props y el estado para los efectos sin importar si est√°s escribiendo el componente como una clase o una funci√≥n.**

Con la API de clases, debes pensar sobre la consistencia por tu cuenta, y verificar que los cambios en cada prop o estado relevantes se manejen por `componentDidUpdate`. De lo contrario, tu componente no es resiliente a los cambios en props y estado. Esto no es ni siquiera un problema espec√≠fico de React. Aplica a cualquier biblioteca de UI que te permita manejar la ¬´creaci√≥n¬ª y ¬´actualizaci√≥n¬ª de forma independiente.

**La API `useEffect` cambia el comportamiento por defecto y promueve la consistencia.** Esto [puede parecer extra√±o en un inicio](/a-complete-guide-to-useeffect/), pero el resultado es un componente que se vuelve m√°s resiliente a los cambios en la l√≥gica. Y como ahora las ¬´dependencias¬ª son expl√≠citas, podemos *verificar* que el efecto es consistente con el uso de una regla de _linter_. ¬°Usamos un _linter_ para detectar errores!

---

### No detengas el flujo de datos en las optimizaciones

Hay otro caso en el que podr√≠as terminar ignorando los cambios a las props. El error puede ocurrir cuando optimizas manualmente tus componentes.

F√≠jate que las formas de optimizaci√≥n que utilizan igualdad superficial como `PureComponente` y `React.memo` con la comparaci√≥n por defecto son seguras.

**Sin embargo, si intentas ¬´optimizar¬ª un componente escribiendo tu propia comparaci√≥n, puede que por error olvides comparar props de funciones:**

```jsx{2-5,7}
class Button extends React.Component {
  shouldComponentUpdate(prevProps) {
    // üî¥ No compara this.props.onClick
    return this.props.color !== prevProps.color;
  }
  render() {
    const onClick = this.props.onClick; // üî¥ No refleja actualizaciones
    const textColor = slowlyCalculateTextColor(this.props.color);
    return (
      <button
        onClick={onClick}
        className={'Button-' + this.props.color + ' Button-text-' + textColor}>
        {this.props.children}
      </button>
    );
  }
}
```

Es f√°cil no darse cuenta de este error a primera vista, porque con las clases pasar√≠as hacia abajo un *m√©todo*, y por tanto tendr√≠a de todas formas la misma identidad:

```jsx{2-4,9-11}
class MyForm extends React.Component {
  handleClick = () => { // ‚úÖ Siempre la misma funci√≥n
    // Hacer algo
  }
  render() {
    return (
      <>
        <h1>Hello!</h1>
        <Button color='green' onClick={this.handleClick}>
          Press me
        </Button>
      </>
    )
  }
}
```

Ocurre entonces que nuestra optimizaci√≥n no se rompe *inmediatamente*. Sin embargo, seguir√° ¬´viendo¬ª el antiguo valor de `onClick` si va cambiando mientras las otras props no lo hacen:

```jsx{6,13-15}
class MyForm extends React.Component {
  state = {
    isEnabled: true
  };
  handleClick = () => {
    this.setState({ isEnabled: false });
    // Hacer algo
  }
  render() {
    return (
      <>
        <h1>Hello!</h1>
        <Button color='green' onClick={
          // üî¥ Button ignora las actualizaciones a la prop onClick
          this.state.isEnabled ? this.handleClick : null
        }>
          Press me
        </Button>
      </>
    )
  }
}
```

En este ejemplo, si se hace clic en el bot√≥n se deber√≠a deshabilitar ‚Äîpero no ocurre porque el componente `Button` ignora las actualizaciones a la prop `onClick`‚Äî.

Esto podr√≠a complicarse m√°s si la identidad de la funci√≥n depende de algo que podr√≠a cambiar en el tiempo, como `draft.content` en este ejemplo:

```jsx{6-7}
  drafts.map(draft =>
    <Button
      color='blue'
      key={draft.id}
      onClick={
        // üî¥ Button ignora las actualizaciones a la prop onClick
        this.handlePublish.bind(this, draft.content)
      }>
      Publish
    </Button>
  )
```

Si bien `draft.content` podr√≠a cambiar en el tiempo, nuestro componente `Button` ignorar√≠a el cambio a la prop `onClick` y continuar√≠a viendo la ¬´primera versi√≥n¬ª de `onClick` ligado al `draft.content` original.

**¬øC√≥mo resolvemos este problema entonces?**

Yo recomiendo evitar implementar `shouldComponentUpdate` y evitar especificar una comparaci√≥n personalizada para `React.memo()`. La comparaci√≥n superficial en `React.memo` respetar√° el cambio de la identidad de la funci√≥n:

```jsx{11}
function Button({ onClick, color, children }) {
  const textColor = slowlyCalculateTextColor(color);
  return (
    <button
      onClick={onClick}
      className={'Button-' + color + ' Button-text-' + textColor}>
      {children}
    </button>
  );
}
export default React.memo(Button); // ‚úÖ Utiliza comparaci√≥n superficial
```

En una clase, `PureComponent` tiene el mismo comportamiento.

Esto nos asegura que el paso de una funci√≥n diferente como prop siempre funcionar√°.

Si insistes en una comparaci√≥n personalizada, **aseg√∫rate de no excluir las funciones:**

```jsx{5}
  shouldComponentUpdate(prevProps) {
    // ‚úÖ Compara this.props.onClick 
    return (
      this.props.color !== prevProps.color ||
      this.props.onClick !== prevProps.onClick
    );
  }
```

Como mencion√© anteriormente, es f√°cil pasar por alto este problema en los componentes de clase, porque las identidades de los m√©todos son a menudo estables (pero no siempre ‚Äîy es ah√≠ d√≥nde los errores son dif√≠ciles de depurar‚Äî). Con los Hooks la situaci√≥n cambia un poco:

1. Las funciones son diferentes *en cada renderizado* por lo que descubres este problema [inmediatamente](https://github.com/facebook/react/issues/14972#issuecomment-468280039).
2. Con `useCallback` y `useContext`, puedes [evitar pasar funciones del todo](https://reactjs.org/docs/hooks-faq.html#how-to-avoid-passing-callbacks-down). Esto te permite optimizar el renderizado sin preocuparte sobre las funciones.

---

Resumiendo esta secci√≥n, **¬°no detengas el flujo de datos!**

Cada vez que uses props y estado analiza qu√© deber√≠a pasar si cambian. En la mayor√≠a de los casos un componente no deber√≠a tratar el renderizado inicial y las actualizaciones de forma distinta. Eso lo hace resiliente a los cambios en la l√≥gica.

Con las clases, es f√°cil olvidarse de las actualizaciones cuando se usan props y estados dentro de los m√©todos de ciclo de vida. Los Hooks te conducen a la forma correcta ‚Äîpero se necesita algunos ajustes mentales si no tienes la costumbre de hacerlo‚Äî.

---

## Principio 2: Estate siempre listo para renderizar

Los componentes de React te permiten escribir c√≥digo sin preocuparte mucho por el tiempo. Describes como la UI *deber√≠a* verse en cualquier momento, y React lo hace realidad. ¬°Aprovecha ese modelo!

No trates de introducir suposiciones innecesarias sobre el tiempo en el comportamiento de tu componente. **Tu componente deber√≠a estar listo para volverse a renderizar en cualquier momento.**

¬øC√≥mo se puede violar este principio? React no lo pone f√°cil ‚Äîpero puedes hacerlo usando el m√©todo de ciclo de vida `componentWillReceiveProps`‚Äî:

```jsx{5-8}
class TextInput extends React.Component {
  state = {
    value: ''
  };
  // üî¥ Reasigna el estado local con cada renderizado del padre
  componentWillReceiveProps(nextProps) {
    this.setState({ value: nextProps.value });
  }
  handleChange = (e) => {
    this.setState({ value: e.target.value });
  };
  render() {
    return (
      <input
        value={this.state.value}
        onChange={this.handleChange}
      />
    );
  }
}
```

En este ejemplo, guardamos `value` en el estado local, pero *tambi√©n* recibimos `value` como prop. Cada vez que ¬´recibimos nuevas props¬ª, volvemos a establecer un `value` en el estado.

**El problema de este patr√≥n es que depende totalmente de una sincronizaci√≥n accidental.**

Quiz√° hoy el padre de este componente se actualiza con poca frecuencia, y por tanto nuestro `TextInput` solo ¬´recibe props¬ª cuando pasa algo importante, como al guardar un formulario.

Pero ma√±ana podr√≠amos a√±adir una animaci√≥n al padre de `TextInput`. Si el padre se rerenderiza m√°s a menudo, ¬°estar√° continuamente [¬´destruyendo¬ª](https://codesandbox.io/s/m3w9zn1z8x) el estado del hijo! Puedes leer m√°s sobre este problema en [¬´Probablemente no necesitas estado derivado¬ª](https://es.reactjs.org/blog/2018/06/07/you-probably-dont-need-derived-state.html).

**¬øC√≥mo podemos arreglarlo entonces?**

Antes que nada, debemos corregir nuestro modelo mental. Necesitamos dejar de pensar en ¬´recibir props¬ª como algo diferente a simplemente ¬´renderizar¬ª. Un rerenderizado causado por un padre no deber√≠a comportarse de forma distinta a un rerenderizado causado por nuestro propio cambio de estado local. **Los componentes deber√≠an ser resilientes al renderizado sea con m√°s o menos frecuencia, porque de lo contrario estar√≠an demasiado acoplados a sus padres.**

*([Esta demo](https://codesandbox.io/s/m3w9zn1z8x) muestra como el rerenderizado puede romper componentes fr√°giles.)*

Si bien hay algunas [soluciones](https://es.reactjs.org/blog/2018/06/07/you-probably-dont-need-derived-state.html#preferred-solutions) [diferentes](https://es.reactjs.org/docs/hooks-faq.html#how-do-i-implement-getderivedstatefromprops) para cuando realmente necesitas derivar estado de la props, usualmente deber√≠as usar o bien un componente completamente controlado:

```jsx
// Opci√≥n 1: Componente completamente controlado.
function TextInput({ value, onChange }) {
  return (
    <input
      value={value}
      onChange={onChange}
    />
  );
}
```

O bien puedes usar un componente no controlado con una key para reiniciarlo:

```jsx
// Opci√≥n 2: Componente completamente no controlado.
function TextInput() {
  const [value, setValue] = useState('');
  return (
    <input
      value={value}
      onChange={e => setValue(e.target.value)}
    />
  );
}

// Podemos reiniciar su estado inicial luego con un cambio de key:
<TextInput key={formId} />
```

Lo que nos deber√≠amos llevar de esta secci√≥n es que tus componentes no deber√≠an romperse simplemente porque su padre o sus padres se rerenderizan m√°s a menudo. El dise√±o de la API de React lo facilita si evitas el antiguo m√©todo `componentWillReceiveProps`.

Para hacer una prueba de estr√©s a tu componente, puedes a√±adir temporalmente este c√≥digo a su padre:

```jsx{2}
componentDidMount() {
  // ¬°No olvides eliminar esto inmediatamente!
  setInterval(() => this.forceUpdate(), 100);
}
```

**No dejes este c√≥digo** ‚Äîes solo una forma r√°pida de comprobar qu√© pasa cuando un padre se rerenderiza m√°s a menudo de lo que esperar√≠as. ¬°No deber√≠a romper al hijo!

---

Podr√≠as estar pensando: ¬´Seguir√© reiniciando el estado cuando las props cambien, pero impedir√© los rerenderizados innecesarios con `PureComponent`¬ª.

¬øEste c√≥digo deber√≠a funcionar, cierto?

```jsx{1-2}
// ü§î Deber√≠a prevenir rerenderizados innecesarios... ¬øcierto?
class TextInput extends React.PureComponent {
  state = {
    value: ''
  };
  // üî¥ Reasigna el estado local en cada renderizado del padre
  componentWillReceiveProps(nextProps) {
    this.setState({ value: nextProps.value });
  }
  handleChange = (e) => {
    this.setState({ value: e.target.value });
  };
  render() {
    return (
      <input
        value={this.state.value}
        onChange={this.handleChange}
      />
    );
  }
}
```

A primera vista podr√≠a parece que este componente soluciona el problema del estado ¬´destruido¬ª en cada rerenderizado. Despu√©s de todo, si las props son las mismas, simplemente no hacemos la actualizaci√≥n ‚Äîy por tanto no se llama a `componentWillReceiveProps`‚Äî.

Sin embargo, esto nos da una falsa sensaci√≥n de seguridad. **Este componente a√∫n no es resiliente a cambios _reales_ en las props.** Por ejemplo, si a√±adimos *otra* prop que cambie a menudo, como un `style` animado, a√∫n ¬´perder√≠amos¬ª el estado interno:

```jsx{2}
<TextInput
  style={{opacity: someValueFromState}}
  value={
    // üî¥ componentWillReceiveProps en TextInput
    // reinicia el estado a este valor en cada tic de la animaci√≥n.
    value
  }
/>
```

Esta v√≠a todav√≠a tiene defectos. Podemos ver que las optimizaciones como `PureComponent`, `shouldComponentUpdate` y `React.memo` no deber√≠an usarse para controlar *comportamiento*. Solo √∫salas para mejorar el *rendimiento* cuando sea necesario. Si el hecho de eliminar una optimizaci√≥n _rompe_ un componente, es que ya era demasiado fr√°gil.

La soluci√≥n en este caso es la misma que hemos descrito anteriormente. No trates ¬´recibir props¬ª como un evento especial. Evita sincronizar props y estado. En la mayor√≠a de los casos, cada valor deber√≠a ser o bien completamente controlado (por props), o completamente no controlado (en estado local). Evita el estado derivado [siempre que puedas](https://es.reactjs.org/blog/2018/06/07/you-probably-dont-need-derived-state.html#preferred-solutions). **¬°Y estate listo siempre para renderizar!**

---

## Principio 3: Ning√∫n componente es un *singleton*

En ocasiones asumimos que un componente determinado solo se mostrar√° una vez: por ejemplo, una barra de navegaci√≥n. Esto puede cumplirse por un tiempo. Sin embargo, hacer esa suposici√≥n a menudo causa problemas de dise√±o que solo salen a la luz m√°s tarde.

Por ejemplo, quiz√° necesites implementar una animaci√≥n *entre* dos componentes `Page` cuando cambia una ruta ‚Äîla p√°gina anterior y la pr√≥xima p√°gina. Ambos componentes deben estar montados durante la animaci√≥n. Sin embargo, en ese momento podr√≠as descubrir que cada uno de esos componente asume que es el √∫nico `Page` en la pantalla.

Es f√°cil comprobar estos problemas. Solo por diversi√≥n, intenta renderizar tu aplicaci√≥n dos veces:

```jsx{3,4}
ReactDOM.render(
  <>
    <MyApp />
    <MyApp />
  </>,
  document.getElementById('root')
);
```

Haz algunos clics. (Podr√≠as necesitar cambiar alg√∫n CSS para este experimento).

**¬øTu aplicaci√≥n a√∫n funciona como era de esperar?** ¬øO ves fallas y errores inesperados? Es una buena idea hacer pruebas de estr√©s en componentes complejos de vez en cuando, y asegurarnos que m√∫ltiples copias de estos no entren en conflicto entre s√≠.

Un ejemplo de un patr√≥n problem√°tico que yo mismo he escrito algunas veces es ¬´limpiar¬ª estado global en `componentWillUnmount`:

```jsx{2-3}
componentWillUnmount() {
  // Resetear algo en un store de Redux
  this.props.resetForm();
}
```

Por supuesto, si hay dos componentes de este tipo en la p√°gina, cuando se desmonta uno de ellos se podr√≠a romper al otro. Resetear estado ¬´global¬ª al *montar* no es mejor:

```jsx{2-3}
componentDidMount() {
  // Resetear algo en un store de Redux
  this.props.resetForm();
}
```

En ese caso el *montaje* de un segundo formulario romper√° el primero.

Estos patrones son buenos indicadores de en d√≥nde se encuentra la fragilidad de nuestros componentes. ***Mostrar* o *esconder* un √°rbol no debiera romper componentes fuera de ese √°rbol.**

Sin importar si planeas renderizar este componente dos veces o no, resolver estos problemas vale la pena a la larga. Te conduce a un dise√±o m√°s resiliente.

---

## Principio 4: Mant√©n el estado local aislado

Considera un componente `Publicaci√≥n` de una red social. Tiene una lista de hilos `Comentario` (que se pueden expandir) y un cuadro de texto `NuevoComentario`.

Los componentes de React pueden tener estado local. ¬øPero, qu√© estado es realmente local? ¬øEs el contenido de la publicaci√≥n estado local o no? ¬øY la lista de comentarios? ¬øO el registro de qu√© hilos de comentarios se expanden? ¬øO el valor del cuadro de texto de comentarios?

Si est√°s acostumbrado a ponerlo todo en un ¬´manejador de estado¬ª, puede ser un desaf√≠o responder esta pregunta. Por tanto aqu√≠ muestro una forma sencilla de tomar la decisi√≥n.

**Si no tienes seguridad si alg√∫n estado es local, preg√∫ntate: ¬´¬øSi este componente se renderizara dos veces, se deber√≠a reflejar esta interacci√≥n en la otra copia?¬ª Cada vez que la respuesta es ¬´no¬ª, has encontrado estado local.**

Por ejemplo, imagina que renderizamos la misma `Publicaci√≥n` dos veces. Veamos diferentes elementos dentro de ella que pueden cambiar.

* *Contenido de la publicaci√≥n.* Quisi√©ramos editar la publicaci√≥n en un √°rbol para actualizarla en otro √°rbol. Por tanto probablemente *no deber√≠a* se el estado local del componente `Publicaci√≥n`. (En su lugar, el contenido de la publicaci√≥n podr√≠a vivir en alguna cach√© como Apollo, Relay, o Redux).

* *Lista de comentarios.* Esto es similar al contenido de la publicaci√≥n. Quisi√©ramos que si se a√±ade un nuevo comentario en un √°rbol que se refleje tambi√©n en el otro √°rbol. Es por esto que idealmente usar√≠amos alg√∫n tipo de cach√©, y **no deber√≠a** ser un estado local de nuestra `Publicaci√≥n`.

* *Qu√© comentarios est√°n expandidos.* Ser√≠a extra√±o que al expandir un comentario en un √°rbol tambi√©n se expandiera en otro √°rbol. En este caso estamos interactuando con una *representaci√≥n particular de la UI* del `Comentario` y no una ¬´entidad comentario¬ª abstracta. Es por eso que un marcador de ¬´expandido¬ª **deber√≠a** ser estado local de `Comentario`.

* *El valor del cuadro de texto de un nuevo comentario.* Ser√≠a raro si al escribir un comentario en un cuadro de texto, tambi√©n se fuera actualizando otro cuadro de texto en otro √°rbol. A menos que los cuadros de texto est√©n claramente agrupados, lo com√∫n es que sean independientes. Por tanto el valor del cuadro de texto **deber√≠a** ser estado local del componente `NuevoComentario`.

No estoy sugiriendo una interpretaci√≥n dogm√°tica de estas reglas. Por supuesto, en una aplicaci√≥n m√°s simple podr√≠as usar estado local para todo, incluidas esas ¬´cach√©s¬ª. Estoy hablando solamente sobre la experiencia de usuario ideal [a partir de los principios fundamentales](/the-elements-of-ui-engineering/).

**Evita convertir estado realmente local en estado global.** Esto entra en nuestro tema de ¬´resiliencia¬ª: hay menos sincronizaciones sorprendentes que puedan estar ocurriendo entre componentes. Como ventaja adicional, esto *tambi√©n* resuelve numerosos tipos de problemas de rendimiento. ¬´Renderizar de m√°s¬ª es un problema mucho menor cuando tu estado est√° en el lugar adecuado.

---

## Resumen

Recordemos estos principios una vez m√°s:

1. **[No detengas el flujo de datos](#principle-1-dont-stop-the-data-flow)** Las props y el estado pueden cambiar, y los componentes deber√≠a manejar esos cambios siempre que ocurran.
2. **[Estate listo siempre para renderizar](#principle-2-always-be-ready-to-render)** Un componente no deber√≠a romperse porque se renderiza con m√°s o menos frecuencia.
3. **[Ning√∫n componente es un *singleton*](#principle-3-no-component-is-a-singleton)** Incluso si un componente se renderiza solo una vez, tu dise√±o mejorar√° si al renderizarlo dos veces no se rompe.
4. **[Mant√©n aislado el estado local](#principle-4-keep-the-local-state-isolated)** Piensa en qu√© estado es local a una representaci√≥n de UI determinada ‚Äîy no levantes el estado m√°s alto de lo que sea necesario‚Äî.

**Estos principios te ayudan a escribir componentes que est√°n [optimizados para el cambio](/optimized-for-change/). Es f√°cil a√±adirlos, cambiarlos y eliminarlos.**

Y lo m√°s importante, una vez que nuestros componentes son resilientes, podemos volver al acuciante dilema de si la props deber√≠an ordenarse alfab√©ticamente.
